("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");
/*
‚ïî‚ßâ‡ºª [ ùêïùê•ùê§ùê≤ùê´ùêûüïäÔ∏èùêåùêÆùê•ùê≠ùê¢ùêÉùêûùêØùê¢ùêúùêû ùêÄùêèùêà ] ùê¢ùê¨ ùêö ùêñùê°ùêöùê≠ùê¨ùêöùê©ùê© ùêåùêÆùê•ùê≠ùê¢ùêèùêÆùê´ùê©ùê®ùê¨ùêû-ùêîùê¨ùêûùê´ùêõùê®ùê≠ ùê∞ùê¢ùê≠ùê° ùêåùê®ùêùùêûùê´ùêöùê≠ùê¢ùê®ùêß,ùêÄùêÆùê≠ùê®ùê¶ùêöùê≠ùê¢ùê®ùêß ùêöùêßùêù ùüèùüéùüé+ ùê¶ùê®ùê´ùêû ùêúùê®ùê¶ùê¶ùêöùêßùêùùê¨! 
‚ïë üêûùêÉùêûùêØùêûùê•ùê®ùê©ùêûùê´ùê¨ +918436686758,917430922909
‚ïë 
‚ïë We won't be responsible for any kind of ban due to this bot.
‚ïë ŒΩ‚Ñì–∫—É—è—î was made for fun purpose and to make group management easier.
‚ïë It's your concern if you spam and gets your account banned.
‚ïë Also, Forks won't be entertained.
‚ïë If you fork this repo and edit plugins, it's your concern for further updates.
‚ïë Forking Repo is fine. But if you edit something we will not provide any help.
‚ïë In short, Fork At Your Own Risk.
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
*/
("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");
require("events").EventEmitter.prototype._maxListeners = 0;
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
process.on("uncaughtException", (error) => {
console.error(error, "Uncaught Exception....");
});

require("./Core/ŒΩc‡ªêrƒì.js");
require("./process");
var {
default: ŒΩ‚Ñì–∫—É—è—îConnect,
useMultiFileAuthState,
DisconnectReason,
generateForwardMessageContent,
prepareWAMessageMedia,
generateWAMessageFromContent,
generateMessageID,
downloadContentFromMessage,
makeInMemoryStore,
MessageRetryMap,
jidDecode,
proto,
} = require("@adiwajshing/baileys");
var fs = require("fs");
var pino = require("pino");
var path = require("path");
var chalk = require("chalk");
var qrcode = require("qrcode");
var CFonts = require("cfonts");
var express = require("express");
var Krone = require("node-cron");
var monGoose = require("mongoose");
var FileType = require("file-type");
var moment = require("moment-timezone");
var Authenticator = require("./Core/Authenticator");
var {
ŒΩkmake,
formatp,
formatDate,
getTime,
isUrl,
clockString,
runtime,
fetchJson,
getBuffer,
jsonformat,
format,
parseMention,
GIFBufferToVideoBuffer,
getRandom,
sleep,
getSizeMedia,
generateMessageTag,
} = require("./Core/myfunc");
var Canvas = require("discord-canvas");
var PhoneNumber = require("awesome-phonenumber");
var {
imageToWebp,
videoToWebp,
writeExifImg,
writeExifVid,
} = require("./Core/exif");
var store = makeInMemoryStore({
logger: pino().child({ level: "silent", stream: "store" }),
});
var getVersionWaweb = () => {
let version;
try {
let a = fetchJson(
"https://web.whatsapp.com/check-update?version=1&platform=web"
);
version = [a.currentVersion.replace(/[.]/g, ", ")];
} catch {
version = [2, 2204, 13];
}
return version;
};
var msgRetryCounterMap = MessageRetryMap;
var autoPoke = Krone.schedule(
"0 0 * * *",
() => {
try {
console.log("Sending Pokemon....");
} catch (error) {
console.log(error);
}
},
{ scheduled: true, timezone: timezone }
);
("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");
async function run() {
var c = require("./process");
var sequelize = c.DATABASE;
try {
await sequelize.authenticate();
console.log("[INFO] Connection has been established successfully.");
} catch (error) {
console.error("[ERROR] Unable to connect to the database:", error);
}
console.log("[INFO] Syncing Database...");
await sequelize.sync();

// var { state, saveCreds } = await useMultiFileAuthState("ŒΩ‚Ñì–∫—É—è—î.–∫—è—É–∫Œ∑z");
var { state, saveCreds } = await Authenticator();
ŒΩ‚Ñìpage = express();
vport = process.env.PORT || 8080;
// ŒΩ‚Ñìpage.get("/", function (rege, ŒΩ‚Ñìp) {
// ŒΩ‚Ñìp.sendFile("Pages/Home.html", { root: __dirname });
// });
// ŒΩ‚Ñìpage.get("/FAQ", function (rege, ŒΩ‚Ñìp) {
// ŒΩ‚Ñìp.sendFile("Pages/FAQ.html", { root: __dirname });
// });
// ŒΩ‚Ñìpage.get("/Command", function (rege, ŒΩ‚Ñìp) {
// ŒΩ‚Ñìp.sendFile("Pages/Command.html", { root: __dirname });
// });
ŒΩ‚Ñìpage.listen(vport, () => {
console.log("ü¶ãùêíùêûùê´ùêØùêûùê´ ùêíùê≠ùêöùê´ùê≠ùêûùêù ùêàùêß: http://localhost:" + vport);
});
("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");
autoPoke.start();
await monGoose
.connect(mongodb, {
useNewUrlParser: true,
useUnifiedTopology: true,
useCreateIndex: true,
useFindAndModify: false,
})
.catch((error) => {
console.log("‚ùåError: Unable to Connected with üçÉùñíùñîùñìùñåùñî.....");
console.log(error);
process.exit(0);
})
.then(console.log("Connected with üçÉùñíùñîùñìùñåùñî....."));
var ŒΩ‚Ñì–∫—É—è—î = ŒΩ‚Ñì–∫—É—è—îConnect({
auth: state,
printQRInTerminal: true,
logger: pino({ level: "silent" }),
defaultQueryTimeoutMs: undefined,
browser: [`vlkyre: ${upVersion || "v5"}`, "Chrome", "4.0.0"],
version: getVersionWaweb() || [2, 2204, 13],
msgRetryCounterMap,
getMessage: async (data) => {
return {
conversation: data,
};
},
});
store.bind(ŒΩ‚Ñì–∫—É—è—î.ev);
("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");
ŒΩ‚Ñì–∫—É—è—î.decodeJid = (jid) => {
if (!jid) return jid;
if (/:\d+@/gi.test(jid)) {
let decode = jidDecode(jid) || {};
return (
(decode.user && decode.server && decode.user + "@" + decode.server) ||
jid
);
} else return jid;
};

ŒΩ‚Ñì–∫—É—è—î.getName = (jid, withoutContact = false) => {
id = ŒΩ‚Ñì–∫—É—è—î.decodeJid(jid);
withoutContact = ŒΩ‚Ñì–∫—É—è—î.withoutContact || withoutContact;
let v;
if (id.endsWith("@g.us"))
return new Promise(async (resolve) => {
v = store.contacts[id] || {};
if (!(v.name || v.subject)) v = ŒΩ‚Ñì–∫—É—è—î.groupMetadata(id) || {};
resolve(
v.name ||
v.subject ||
PhoneNumber("+" + id.replace("@s.whatsapp.net", "")).getNumber(
"international"
)
);
});
else
v =
id === "0@s.whatsapp.net"
? {
id,
name: "WhatsApp",
}
: id === ŒΩ‚Ñì–∫—É—è—î.decodeJid(ŒΩ‚Ñì–∫—É—è—î.user.id)
? ŒΩ‚Ñì–∫—É—è—î.user
: store.contacts[id] || {};
return (
(withoutContact ? "" : v.name) ||
v.subject ||
v.verifiedName ||
PhoneNumber("+" + jid.replace("@s.whatsapp.net", "")).getNumber(
"international"
)
);
};

ŒΩ‚Ñì–∫—É—è—î.sendContact = async (jid, kon, quoted = "", opts = {}) => {
let list = [];
for (let i of kon) {
list.push({
displayName: await ŒΩ‚Ñì–∫—É—è—î.getName(i + "@s.whatsapp.net"),
vcard: `BEGIN:VCARD\nVERSION:3.0\nN:${await ŒΩ‚Ñì–∫—É—è—î.getName(
i + "@s.whatsapp.net"
)}\nFN:${await ŒΩ‚Ñì–∫—É—è—î.getName(
i + "@s.whatsapp.net"
)}\nitem1.TEL;waid=${i}:${i}\nitem1.X-ABLabel:Phone\nitem2.EMAIL;type=INTERNET:ŒΩ‚Ñì–∫—É—è—îbots@gmail.com\nitem2.X-ABLabel:Email\nitem3.URL:https://instagram.com/riki_4932\nitem3.X-ABLabel:Instagram\nitem4.ADR:;;India;;;;\nitem4.X-ABLabel:Region\nEND:VCARD`,
});
}
ŒΩ‚Ñì–∫—É—è—î.sendMessage(
jid,
{
contacts: { displayName: `${list.length} contact`, contacts: list },
...opts,
},
{ quoted }
);
};

ŒΩ‚Ñì–∫—É—è—î.public = true;
ŒΩ‚Ñì–∫—É—è—î.serializeM = (ŒΩ‚Ñìc–ΩŒ±—Ç) => ŒΩkmake(ŒΩ‚Ñì–∫—É—è—î, ŒΩ‚Ñìc–ΩŒ±—Ç, store);
("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");
ŒΩ‚Ñì–∫—É—è—î.send5ButImg = async (
jid,
text = "",
footer = "",
img,
but = [],
options = {}
) => {
let message = await prepareWAMessageMedia(
{ image: img },
{ upload: ŒΩ‚Ñì–∫—É—è—î.waUploadToServer }
);
var template = generateWAMessageFromContent(
ŒΩ‚Ñìc–ΩŒ±—Ç.chat,
proto.Message.fromObject({
templateMessage: {
hydratedTemplate: {
imageMessage: message.imageMessage,
hydratedContentText: text,
hydratedFooterText: footer,
hydratedButtons: but,
},
},
}),
options
);
ŒΩ‚Ñì–∫—É—è—î.relayMessage(jid, template.message, { messageId: template.key.id });
};

/**
*
* @param {*} jid
* @param {*} buttons
* @param {*} caption
* @param {*} footer
* @param {*} quoted
* @param {*} options
*/
ŒΩ‚Ñì–∫—É—è—î.sendButtonText = (
jid,
buttons = [],
text,
footer,
quoted = "",
options = {}
) => {
let buttonMessage = {
text,
footer,
buttons,
headerType: 2,
...options,
};
ŒΩ‚Ñì–∫—É—è—î.sendMessage(jid, buttonMessage, { quoted, ...options });
};

/**
*
* @param {*} jid
* @param {*} text
* @param {*} quoted
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.sendText = (jid, text, quoted = "", options) =>
ŒΩ‚Ñì–∫—É—è—î.sendMessage(jid, { text: text, ...options }, { quoted });

/**
*
* @param {*} jid
* @param {*} path
* @param {*} caption
* @param {*} quoted
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.sendImage = async (jid, path, caption = "", quoted = "", options) => {
let buffer = Buffer.isBuffer(path)
? path
: /^data:.*?\/.*?;base64,/i.test(path)
? Buffer.from(path.split`,`[1], "base64")
: /^https?:\/\//.test(path)
? await await getBuffer(path)
: fs.existsSync(path)
? fs.readFileSync(path)
: Buffer.alloc(0);
return await ŒΩ‚Ñì–∫—É—è—î.sendMessage(
jid,
{ image: buffer, caption: caption, ...options },
{ quoted }
);
};

/**
*
* @param {*} jid
* @param {*} path
* @param {*} caption
* @param {*} quoted
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.sendVideo = async (
jid,
path,
caption = "",
quoted = "",
gif = false,
options
) => {
let buffer = Buffer.isBuffer(path)
? path
: /^data:.*?\/.*?;base64,/i.test(path)
? Buffer.from(path.split`,`[1], "base64")
: /^https?:\/\//.test(path)
? await await getBuffer(path)
: fs.existsSync(path)
? fs.readFileSync(path)
: Buffer.alloc(0);
return await ŒΩ‚Ñì–∫—É—è—î.sendMessage(
jid,
{ video: buffer, caption: caption, gifPlayback: gif, ...options },
{ quoted }
);
};

/**
*
* @param {*} jid
* @param {*} path
* @param {*} quoted
* @param {*} mime
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.sendAudio = async (jid, path, quoted = "", ptt = false, options) => {
let buffer = Buffer.isBuffer(path)
? path
: /^data:.*?\/.*?;base64,/i.test(path)
? Buffer.from(path.split`,`[1], "base64")
: /^https?:\/\//.test(path)
? await await getBuffer(path)
: fs.existsSync(path)
? fs.readFileSync(path)
: Buffer.alloc(0);
return await ŒΩ‚Ñì–∫—É—è—î.sendMessage(
jid,
{ audio: buffer, ptt: ptt, ...options },
{ quoted }
);
};

/**
*
* @param {*} jid
* @param {*} text
* @param {*} quoted
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.sendTextWithMentions = async (jid, text, quoted, options = {}) =>
ŒΩ‚Ñì–∫—É—è—î.sendMessage(
jid,
{
text: text,
contextInfo: {
mentionedJid: [...text.matchAll(/@(\d{0,16})/g)].map(
(v) => v[1] + "@s.whatsapp.net"
),
},
...options,
},
{ quoted }
);

/**
*
* @param {*} jid
* @param {*} path
* @param {*} quoted
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.sendImageAsSticker = async (jid, path, quoted, options = {}) => {
let buff = Buffer.isBuffer(path)
? path
: /^data:.*?\/.*?;base64,/i.test(path)
? Buffer.from(path.split`,`[1], "base64")
: /^https?:\/\//.test(path)
? await await getBuffer(path)
: fs.existsSync(path)
? fs.readFileSync(path)
: Buffer.alloc(0);
let buffer;
if (options && (options.packname || options.author)) {
buffer = await writeExifImg(buff, options);
} else {
buffer = await imageToWebp(buff);
}

await ŒΩ‚Ñì–∫—É—è—î.sendMessage(
jid,
{ sticker: { url: buffer }, ...options },
{ quoted }
);
return buffer;
};

/**
*
* @param {*} jid
* @param {*} path
* @param {*} quoted
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.sendVideoAsSticker = async (jid, path, quoted, options = {}) => {
let buff = Buffer.isBuffer(path)
? path
: /^data:.*?\/.*?;base64,/i.test(path)
? Buffer.from(path.split`,`[1], "base64")
: /^https?:\/\//.test(path)
? await await getBuffer(path)
: fs.existsSync(path)
? fs.readFileSync(path)
: Buffer.alloc(0);
let buffer;
if (options && (options.packname || options.author)) {
buffer = await writeExifVid(buff, options);
} else {
buffer = await videoToWebp(buff);
}

await ŒΩ‚Ñì–∫—É—è—î.sendMessage(
jid,
{ sticker: { url: buffer }, ...options },
{ quoted }
);
return buffer;
};

/**
*
* @param {*} message
* @param {*} filename
* @param {*} attachExtension
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.downloadAndSaveMediaMessage = async (
message,
filename,
attachExtension = true
) => {
let quoted = message.msg ? message.msg : message;
let mime = (message.msg || message).mimetype || "";
let messageType = message.mtype
? message.mtype.replace(/Message/gi, "")
: mime.split("/")[0];
var stream = await downloadContentFromMessage(quoted, messageType);
let buffer = Buffer.from([]);
for await (var chunk of stream) {
buffer = Buffer.concat([buffer, chunk]);
}
let type = await FileType.fromBuffer(buffer);
trueFileName = attachExtension ? filename + "." + type.ext : filename;
// save to file
await fs.writeFileSync(trueFileName, buffer);
return trueFileName;
};

ŒΩ‚Ñì–∫—É—è—î.downloadMediaMessage = async (message) => {
let mime = (message.msg || message).mimetype || "";
let messageType = message.mtype
? message.mtype.replace(/Message/gi, "")
: mime.split("/")[0];
var stream = await downloadContentFromMessage(message, messageType);
let buffer = Buffer.from([]);
for await (var chunk of stream) {
buffer = Buffer.concat([buffer, chunk]);
}

return buffer;
};

/**
*
* @param {*} jid
* @param {*} path
* @param {*} filename
* @param {*} caption
* @param {*} quoted
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.sendMedia = async (
jid,
path,
fileName = "",
caption = "",
quoted = "",
options = {}
) => {
let types = await ŒΩ‚Ñì–∫—É—è—î.getFile(path, true);
let { mime, ext, res, data, filename } = types;
if ((res && res.status !== 200) || file.length <= 65536) {
try {
throw { json: JSON.parse(file.toString()) };
} catch (e) {
if (e.json) throw e.json;
}
}
let type = "",
mimetype = mime,
pathFile = filename;
if (options.asDocument) type = "document";
if (options.asSticker || /webp/.test(mime)) {
let { writeExif } = require("./Core/exif");
let media = { mimetype: mime, data };
pathFile = await writeExif(media, {
packname: options.packname ? options.packname : global.packname,
author: options.author ? options.author : global.author,
categories: options.categories ? options.categories : [],
});
await fs.promises.unlink(filename);
type = "sticker";
mimetype = "image/webp";
} else if (/image/.test(mime)) type = "image";
else if (/video/.test(mime)) type = "video";
else if (/audio/.test(mime)) type = "audio";
else type = "document";
await ŒΩ‚Ñì–∫—É—è—î.sendMessage(
jid,
{ [type]: { url: pathFile }, caption, mimetype, fileName, ...options },
{ quoted, ...options }
);
return fs.promises.unlink(pathFile);
};

/**
*
* @param {*} jid
* @param {*} message
* @param {*} forceForward
* @param {*} options
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.copyNForward = async (
jid,
message,
forceForward = false,
options = {}
) => {
let vtype;
if (options.readViewOnce) {
message.message =
message.message &&
message.message.ephemeralMessage &&
message.message.ephemeralMessage.message
? message.message.ephemeralMessage.message
: message.message || undefined;
vtype = Object.keys(message.message.viewOnceMessage.message)[0];
delete (message.message && message.message.ignore
? message.message.ignore
: message.message || undefined);
delete message.message.viewOnceMessage.message[vtype].viewOnce;
message.message = {
...message.message.viewOnceMessage.message,
};
}

let mtype = Object.keys(message.message)[0];
let content = await generateForwardMessageContent(message, forceForward);
let ctype = Object.keys(content)[0];
let context = {};
if (mtype != "conversation") context = message.message[mtype].contextInfo;
content[ctype].contextInfo = {
...context,
...content[ctype].contextInfo,
};
var waMessage = await generateWAMessageFromContent(
jid,
content,
options
? {
...content[ctype],
...options,
...(options.contextInfo
? {
contextInfo: {
...content[ctype].contextInfo,
...options.contextInfo,
},
}
: {}),
}
: {}
);
await ŒΩ‚Ñì–∫—É—è—î.relayMessage(jid, waMessage.message, {
messageId: waMessage.key.id,
});
return waMessage;
};

ŒΩ‚Ñì–∫—É—è—î.cMod = (
jid,
copy,
text = "",
sender = ŒΩ‚Ñì–∫—É—è—î.user.id,
options = {}
) => {
let mtype = Object.keys(copy.message)[0];
let isEphemeral = mtype === "ephemeralMessage";
if (isEphemeral) {
mtype = Object.keys(copy.message.ephemeralMessage.message)[0];
}
let msg = isEphemeral
? copy.message.ephemeralMessage.message
: copy.message;
let content = msg[mtype];
if (typeof content === "string") msg[mtype] = text || content;
else if (content.caption) content.caption = text || content.caption;
else if (content.text) content.text = text || content.text;
if (typeof content !== "string")
msg[mtype] = {
...content,
...options,
};
if (copy.key.participant)
sender = copy.key.participant = sender || copy.key.participant;
else if (copy.key.participant)
sender = copy.key.participant = sender || copy.key.participant;
if (copy.key.remoteJid.includes("@s.whatsapp.net"))
sender = sender || copy.key.remoteJid;
else if (copy.key.remoteJid.includes("@broadcast"))
sender = sender || copy.key.remoteJid;
copy.key.remoteJid = jid;
copy.key.fromMe = sender === ŒΩ‚Ñì–∫—É—è—î.user.id;

return proto.WebMessageInfo.fromObject(copy);
};

/**
*
* @param {*} path
* @returns
*/
ŒΩ‚Ñì–∫—É—è—î.getFile = async (PATH, save) => {
let res;
let data = Buffer.isBuffer(PATH)
? PATH
: /^data:.*?\/.*?;base64,/i.test(PATH)
? Buffer.from(PATH.split`,`[1], "base64")
: /^https?:\/\//.test(PATH)
? await (res = await getBuffer(PATH))
: fs.existsSync(PATH)
? ((filename = PATH), fs.readFileSync(PATH))
: typeof PATH === "string"
? PATH
: Buffer.alloc(0);
let type = (await FileType.fromBuffer(data)) || {
mime: "application/octet-stream",
ext: ".Bin",
};
filename = path.join(
__filename,
"../Bin/" + new Date() * 1 + "." + type.ext
);
if (data && save) fs.promises.writeFile(filename, data);
return {
res,
filename,
size: await getSizeMedia(data),
...type,
data,
};
};
("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");
ŒΩ‚Ñì–∫—É—è—î.ws.on("CB:call", async (update) => {
await require("./Events/caller")(update, ŒΩ‚Ñì–∫—É—è—î);
});
ŒΩ‚Ñì–∫—É—è—î.ev.on("messages.upsert", async (update) => {
await require("./Events/message-upsert")(
update,
ŒΩ‚Ñì–∫—É—è—î,
ŒΩkmake,
store,
ŒΩ‚Ñìpage
);
});
ŒΩ‚Ñì–∫—É—è—î.ev.on("group-participants.update", async (update, ŒΩ‚Ñì–∫—É—è—î) => {
await require("./Events/group-parts")(update);
});
ŒΩ‚Ñì–∫—É—è—î.ev.on("connection.update", async (update) => {
await require("./Events/connection")(update, ŒΩ‚Ñì–∫—É—è—î, DisconnectReason, run);
});
ŒΩ‚Ñì–∫—É—è—î.ev.on("contacts.update", async (update) => {
await require("./Events/contacts")(update, ŒΩ‚Ñì–∫—É—è—î, store);
});
ŒΩ‚Ñì–∫—É—è—î.ev.on("groups.update", async (update) => {
await require("./Events/group-update")(update, ŒΩ‚Ñì–∫—É—è—î, store);
});
ŒΩ‚Ñì–∫—É—è—î.ev.on("creds.update", () => {
saveCreds();
});
return ŒΩ‚Ñì–∫—É—è—î;
}
run();
("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");
/*
‚ïî‚ßâ‡ºª [ ùêïùê•ùê§ùê≤ùê´ùêûüïäÔ∏èùêåùêÆùê•ùê≠ùê¢ùêÉùêûùêØùê¢ùêúùêû ùêÄùêèùêà ] ùê¢ùê¨ ùêö ùêñùê°ùêöùê≠ùê¨ùêöùê©ùê© ùêåùêÆùê•ùê≠ùê¢ùêèùêÆùê´ùê©ùê®ùê¨ùêû-ùêîùê¨ùêûùê´ùêõùê®ùê≠ ùê∞ùê¢ùê≠ùê° ùêåùê®ùêùùêûùê´ùêöùê≠ùê¢ùê®ùêß,ùêÄùêÆùê≠ùê®ùê¶ùêöùê≠ùê¢ùê®ùêß ùêöùêßùêù ùüèùüéùüé+ ùê¶ùê®ùê´ùêû ùêúùê®ùê¶ùê¶ùêöùêßùêùùê¨! 
‚ïë üêûùêÉùêûùêØùêûùê•ùê®ùê©ùêûùê´ùê¨ +918436686758,917430922909
‚ïë 
‚ïë We won't be responsible for any kind of ban due to this bot.
‚ïë ŒΩ‚Ñì–∫—É—è—î was made for fun purpose and to make group management easier.
‚ïë It's your concern if you spam and gets your account banned.
‚ïë Also, Forks won't be entertained.
‚ïë If you fork this repo and edit plugins, it's your concern for further updates.
‚ïë Forking Repo is fine. But if you edit something we will not provide any help.
‚ïë In short, Fork At Your Own Risk.
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
*/
("‚óé‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±[ ŒΩ‚Ñì–∫—É—è—î –≤œÉ—Ç –≤—É –∫—è—É–∫Œ∑z ]‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚ò±‚óé");

// git pull --rebase origin ùêïùê•ùê§ùê≤ùê´ùêû-ùêñùêûùêõ-ùêÅùêöùê¨ùêûùêù
// git push origin ùêïùê•ùê§ùê≤ùê´ùêû-ùêñùêûùêõ-ùêÅùêöùê¨ùêûùêù
